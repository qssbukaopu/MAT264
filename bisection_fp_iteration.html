<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Numerical Methods - Bisection & Fixed Point Iteration</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    function NumericalMethods() {
      const [method, setMethod] = useState('bisection');
      const [iterations, setIterations] = useState([]);
      const [currentStep, setCurrentStep] = useState(0);
      const [isAnimating, setIsAnimating] = useState(false);
      const [calculated, setCalculated] = useState(false);
      
      const [toleranceExp, setToleranceExp] = useState(6);
      const [maxIter, setMaxIter] = useState(50);
      const [funcInput, setFuncInput] = useState('x*x - 2');
      const [funcError, setFuncError] = useState('');
      
      const [a, setA] = useState(0);
      const [b, setB] = useState(2);
      
      const [x0, setX0] = useState(0.5);
      const [fpFuncInput, setFpFuncInput] = useState('Math.cos(x)');
      
      const canvasRef = useRef(null);
      const tolerance = Math.pow(10, -toleranceExp);

      const f = (x) => {
        try {
          const func = new Function('x', 'Math', `return ${funcInput}`);
          return func(x, Math);
        } catch (error) {
          return NaN;
        }
      };

      const g = (x) => {
        try {
          const func = new Function('x', 'Math', `return ${fpFuncInput}`);
          return func(x, Math);
        } catch (error) {
          return NaN;
        }
      };

      const runBisection = () => {
        try {
          const fa = f(parseFloat(a));
          const fb = f(parseFloat(b));
          
          if (isNaN(fa) || !isFinite(fa) || isNaN(fb) || !isFinite(fb)) {
            setFuncError('Invalid function. Please check your input.');
            return false;
          }
          
          if (fa * fb > 0) {
            setFuncError('f(a) and f(b) must have opposite signs');
            return false;
          }
          
          setFuncError('');
        } catch (error) {
          setFuncError('Error evaluating function: ' + error.message);
          return false;
        }

        const result = [];
        let aVal = parseFloat(a);
        let bVal = parseFloat(b);
        let converged = false;
        let prevC = null;
        
        const sampleRate = maxIter > 1000 ? Math.floor(maxIter / 1000) : 1;

        for (let i = 0; i < maxIter; i++) {
          const c = (aVal + bVal) / 2;
          const fc = f(c);
          
          const error = prevC !== null ? Math.abs(c - prevC) : Math.abs(bVal - aVal) / 2;
          
          if (isNaN(fc) || !isFinite(fc)) {
            setFuncError(`Function produced invalid value at iteration ${i}`);
            break;
          }
          
          if (i % sampleRate === 0 || i < 20 || i === maxIter - 1) {
            result.push({
              iteration: i,
              x: c,
              fx: fc,
              a: aVal,
              b: bVal,
              error: error,
            });
          }

          if (prevC !== null && error < tolerance) {
            if (i % sampleRate !== 0) {
              result.push({
                iteration: i,
                x: c,
                fx: fc,
                a: aVal,
                b: bVal,
                error: error,
              });
            }
            converged = true;
            break;
          }
          
          const fa = f(aVal);
          if (fa * fc < 0) {
            bVal = c;
          } else {
            aVal = c;
          }
          
          prevC = c;
        }

        setIterations(result);
        return converged;
      };

      const runFixedPoint = () => {
        try {
          const testVal = g(1);
          if (isNaN(testVal) || !isFinite(testVal)) {
            setFuncError('Invalid function. Please check your input.');
            return false;
          }
          setFuncError('');
        } catch (error) {
          setFuncError('Error evaluating function: ' + error.message);
          return false;
        }

        const result = [];
        let x = parseFloat(x0);
        let converged = false;
        
        const sampleRate = maxIter > 1000 ? Math.floor(maxIter / 1000) : 1;

        for (let i = 0; i < maxIter; i++) {
          const gx = g(x);
          
          if (isNaN(gx) || !isFinite(gx)) {
            setFuncError(`Function produced invalid value at iteration ${i}`);
            break;
          }
          
          const error = Math.abs(gx - x);
          
          if (i % sampleRate === 0 || i < 20 || i === maxIter - 1) {
            result.push({
              iteration: i,
              x: x,
              gx: gx,
              error: error,
            });
          }

          if (error < tolerance) {
            if (i % sampleRate !== 0) {
              result.push({
                iteration: i + 1,
                x: gx,
                gx: g(gx),
                error: Math.abs(g(gx) - gx),
              });
            }
            converged = true;
            break;
          }
          
          x = gx;
        }

        setIterations(result);
        return converged;
      };

      const animate = () => {
        if (currentStep < iterations.length - 1) {
          setCurrentStep(currentStep + 1);
        } else {
          setIsAnimating(false);
        }
      };

      useEffect(() => {
        if (isAnimating) {
          const timer = setTimeout(animate, 500);
          return () => clearTimeout(timer);
        }
      }, [isAnimating, currentStep]);

      useEffect(() => {
        if (!canvasRef.current || iterations.length === 0) return;
        
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, width, height);
        
        let xMin, xMax, yMin, yMax;
        
        if (method === 'bisection') {
          xMin = parseFloat(a) - 0.5;
          xMax = parseFloat(b) + 0.5;
          
          yMin = Infinity;
          yMax = -Infinity;
          for (let x = xMin; x <= xMax; x += (xMax - xMin) / 100) {
            const y = f(x);
            if (isFinite(y)) {
              yMin = Math.min(yMin, y);
              yMax = Math.max(yMax, y);
            }
          }
          const yRange = yMax - yMin;
          yMin -= yRange * 0.2;
          yMax += yRange * 0.2;
        } else {
          const aNum = parseFloat(a);
          const bNum = parseFloat(b);
          const range = bNum - aNum;
          xMin = aNum - range * 0.2;
          xMax = bNum + range * 0.2;
          
          yMin = Infinity;
          yMax = -Infinity;
          for (let x = xMin; x <= xMax; x += (xMax - xMin) / 100) {
            const y = g(x);
            if (isFinite(y)) {
              yMin = Math.min(yMin, y, x);
              yMax = Math.max(yMax, y, x);
            }
          }
          const yRange = yMax - yMin;
          yMin -= yRange * 0.2;
          yMax += yRange * 0.2;
        }
        
        const toCanvasX = (x) => ((x - xMin) / (xMax - xMin)) * width;
        const toCanvasY = (y) => height - ((y - yMin) / (yMax - yMin)) * height;
        
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        const xStep = (xMax - xMin) / 8;
        const yStep = (yMax - yMin) / 8;
        for (let x = Math.ceil(xMin / xStep) * xStep; x <= xMax; x += xStep) {
          ctx.beginPath();
          ctx.moveTo(toCanvasX(x), 0);
          ctx.lineTo(toCanvasX(x), height);
          ctx.stroke();
        }
        for (let y = Math.ceil(yMin / yStep) * yStep; y <= yMax; y += yStep) {
          ctx.beginPath();
          ctx.moveTo(0, toCanvasY(y));
          ctx.lineTo(width, toCanvasY(y));
          ctx.stroke();
        }
        
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        if (xMin <= 0 && xMax >= 0) {
          ctx.beginPath();
          ctx.moveTo(toCanvasX(0), 0);
          ctx.lineTo(toCanvasX(0), height);
          ctx.stroke();
        }
        if (yMin <= 0 && yMax >= 0) {
          ctx.beginPath();
          ctx.moveTo(0, toCanvasY(0));
          ctx.lineTo(width, toCanvasY(0));
          ctx.stroke();
        }
        
        if (method === 'bisection') {
          ctx.strokeStyle = '#8b5cf6';
          ctx.lineWidth = 2;
          ctx.beginPath();
          let firstPoint = true;
          for (let x = xMin; x <= xMax; x += (xMax - xMin) / 500) {
            const y = f(x);
            if (isFinite(y) && !isNaN(y)) {
              const cx = toCanvasX(x);
              const cy = toCanvasY(y);
              if (cy >= -50 && cy <= height + 50) {
                if (firstPoint) {
                  ctx.moveTo(cx, cy);
                  firstPoint = false;
                } else {
                  ctx.lineTo(cx, cy);
                }
              } else {
                firstPoint = true;
              }
            } else {
              firstPoint = true;
            }
          }
          ctx.stroke();
          
          if (isAnimating && currentStep < iterations.length) {
            const iter = iterations[currentStep];
            
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(toCanvasX(iter.a), toCanvasY(0));
            ctx.lineTo(toCanvasX(iter.b), toCanvasY(0));
            ctx.stroke();
            
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(toCanvasX(iter.x), toCanvasY(iter.fx), 5, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(toCanvasX(iter.x), toCanvasY(0));
            ctx.lineTo(toCanvasX(iter.x), toCanvasY(iter.fx));
            ctx.stroke();
            ctx.setLineDash([]);
          }
        } else {
          ctx.strokeStyle = '#8b5cf6';
          ctx.lineWidth = 2;
          ctx.beginPath();
          let firstPoint = true;
          for (let x = xMin; x <= xMax; x += 0.01) {
            const y = g(x);
            if (isFinite(y) && !isNaN(y) && y >= yMin && y <= yMax) {
              const cx = toCanvasX(x);
              const cy = toCanvasY(y);
              if (firstPoint) {
                ctx.moveTo(cx, cy);
                firstPoint = false;
              } else {
                ctx.lineTo(cx, cy);
              }
            } else {
              firstPoint = true;
            }
          }
          ctx.stroke();
          
          ctx.strokeStyle = '#3b82f6';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(toCanvasX(xMin), toCanvasY(xMin));
          ctx.lineTo(toCanvasX(xMax), toCanvasY(xMax));
          ctx.stroke();
          
          if (isAnimating && currentStep < iterations.length) {
            const iter = iterations[currentStep];
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(toCanvasX(iter.x), toCanvasY(iter.gx), 5, 0, 2 * Math.PI);
            ctx.fill();
          }
        }
      }, [iterations, isAnimating, currentStep, method, a, b, funcInput, fpFuncInput, x0]);

      const handleStart = () => {
        if (method === 'bisection') {
          runBisection();
        } else {
          runFixedPoint();
        }
        setCalculated(true);
        setCurrentStep(0);
        setIsAnimating(false);
      };

      const handleAnimate = () => {
        setCurrentStep(0);
        setIsAnimating(true);
      };

      const handleReset = () => {
        setIterations([]);
        setCurrentStep(0);
        setIsAnimating(false);
        setCalculated(false);
      };

      const handleMethodChange = (newMethod) => {
        setMethod(newMethod);
        handleReset();
        setFuncError('');
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-8">
          <div className="max-w-6xl mx-auto">
            <div className="bg-white rounded-xl shadow-2xl p-8">
              <h1 className="text-4xl font-bold text-indigo-900 mb-2">Numerical Methods</h1>
              <p className="text-gray-600 mb-6">Root finding and fixed point iteration</p>

              <div className="flex gap-3 mb-8">
                <button
                  onClick={() => handleMethodChange('bisection')}
                  className={`flex-1 py-3 px-6 rounded-lg font-semibold transition ${
                    method === 'bisection'
                      ? 'bg-indigo-600 text-white shadow-lg'
                      : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                  }`}
                >
                  Bisection Method
                </button>
                <button
                  onClick={() => handleMethodChange('fixedpoint')}
                  className={`flex-1 py-3 px-6 rounded-lg font-semibold transition ${
                    method === 'fixedpoint'
                      ? 'bg-indigo-600 text-white shadow-lg'
                      : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                  }`}
                >
                  Fixed Point Iteration
                </button>
              </div>

              <div className="grid md:grid-cols-2 gap-8 mb-8">
                <div className="bg-indigo-50 rounded-lg p-6">
                  <h2 className="text-xl font-semibold text-indigo-800 mb-4">Parameters</h2>
                  
                  <div className="space-y-4">
                    {method === 'bisection' ? (
                      <>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-2">
                            Function f(x):
                          </label>
                          <input
                            type="text"
                            value={funcInput}
                            onChange={(e) => setFuncInput(e.target.value)}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg font-mono text-sm"
                            placeholder="e.g., x*x - 2 or Math.sin(x)"
                            disabled={isAnimating}
                          />
                          {funcError && (
                            <p className="text-red-600 text-xs mt-1">{funcError}</p>
                          )}
                          <p className="text-xs text-gray-500 mt-1">
                            Finding x where f(x) = 0. Use Math.cos, Math.sin, Math.exp, etc.
                          </p>
                        </div>

                        <div className="grid grid-cols-2 gap-3">
                          <div>
                            <label className="block text-sm font-medium text-gray-700 mb-2">
                              Left endpoint (a):
                            </label>
                            <input
                              type="number"
                              step="0.1"
                              value={a}
                              onChange={(e) => setA(e.target.value)}
                              className="w-full px-3 py-2 border border-gray-300 rounded-lg"
                              disabled={isAnimating}
                            />
                          </div>
                          <div>
                            <label className="block text-sm font-medium text-gray-700 mb-2">
                              Right endpoint (b):
                            </label>
                            <input
                              type="number"
                              step="0.1"
                              value={b}
                              onChange={(e) => setB(e.target.value)}
                              className="w-full px-3 py-2 border border-gray-300 rounded-lg"
                              disabled={isAnimating}
                            />
                          </div>
                        </div>
                      </>
                    ) : (
                      <>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-2">
                            Function g(x):
                          </label>
                          <input
                            type="text"
                            value={fpFuncInput}
                            onChange={(e) => setFpFuncInput(e.target.value)}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg font-mono text-sm"
                            placeholder="e.g., Math.cos(x) or x/2 + 1"
                            disabled={isAnimating}
                          />
                          {funcError && (
                            <p className="text-red-600 text-xs mt-1">{funcError}</p>
                          )}
                          <p className="text-xs text-gray-500 mt-1">
                            Finding x such that x = g(x). Use Math.cos, Math.sin, Math.exp, Math.sqrt, etc.
                          </p>
                        </div>

                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-2">
                            Initial Guess (x₀):
                          </label>
                          <input
                            type="number"
                            step="0.1"
                            value={x0}
                            onChange={(e) => setX0(e.target.value)}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg"
                            disabled={isAnimating}
                          />
                        </div>
                      </>
                    )}

                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">
                        Tolerance: 10<sup>-{toleranceExp}</sup> = {tolerance.toExponential(2)}
                      </label>
                      <input
                        type="range"
                        min="1"
                        max="15"
                        step="1"
                        value={toleranceExp}
                        onChange={(e) => setToleranceExp(parseInt(e.target.value))}
                        className="w-full"
                        disabled={isAnimating}
                      />
                      <div className="flex justify-between text-xs text-gray-500 mt-1">
                        <span>10⁻¹</span>
                        <span>10⁻¹⁵</span>
                      </div>
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">
                        Max Iterations:
                      </label>
                      <input
                        type="number"
                        min="1"
                        max="1000000"
                        step="1"
                        value={maxIter}
                        onChange={(e) => setMaxIter(parseInt(e.target.value) || 1)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg"
                        disabled={isAnimating}
                      />
                    </div>
                  </div>

                  <div className="flex gap-3 mt-6">
                    <button
                      onClick={handleStart}
                      disabled={isAnimating}
                      className="flex-1 bg-indigo-600 text-white px-4 py-2 rounded-lg font-semibold hover:bg-indigo-700 disabled:bg-gray-400 transition"
                    >
                      Calculate
                    </button>
                    <button
                      onClick={handleAnimate}
                      disabled={!calculated || isAnimating}
                      className="flex-1 bg-green-600 text-white px-4 py-2 rounded-lg font-semibold hover:bg-green-700 disabled:bg-gray-400 transition"
                    >
                      Animate
                    </button>
                    <button
                      onClick={handleReset}
                      disabled={isAnimating}
                      className="flex-1 bg-red-600 text-white px-4 py-2 rounded-lg font-semibold hover:bg-red-700 disabled:bg-gray-400 transition"
                    >
                      Reset
                    </button>
                  </div>
                </div>

                <div className="bg-amber-50 rounded-lg p-6">
                  <h2 className="text-xl font-semibold text-amber-900 mb-4">Algorithm</h2>
                  {method === 'bisection' ? (
                    <div className="bg-white p-4 rounded font-mono text-sm">
                      <div className="space-y-1">
                        <div>Given: f(x), [a, b], ε (tolerance)</div>
                        <div>Require: f(a) · f(b) &lt; 0</div>
                        <div className="mt-3">x₀ ← (a + b) / 2</div>
                        <div>n ← 0</div>
                        <div>repeat</div>
                        <div className="ml-4">c ← (a + b) / 2</div>
                        <div className="ml-4">if f(a) · f(c) &lt; 0 then</div>
                        <div className="ml-8">b ← c</div>
                        <div className="ml-4">else</div>
                        <div className="ml-8">a ← c</div>
                        <div className="ml-4">xₙ ← c</div>
                        <div className="ml-4">n ← n + 1</div>
                        <div>until |xₙ - xₙ₋₁| &lt; ε</div>
                        <div className="mt-3">return xₙ</div>
                      </div>
                    </div>
                  ) : (
                    <div className="bg-white p-4 rounded font-mono text-sm">
                      <div className="space-y-1">
                        <div>Given: g(x), x₀, ε (tolerance)</div>
                        <div className="mt-3">n ← 0</div>
                        <div>repeat</div>
                        <div className="ml-4">xₙ₊₁ ← g(xₙ)</div>
                        <div className="ml-4">n ← n + 1</div>
                        <div>until |xₙ₊₁ - xₙ| &lt; ε</div>
                        <div className="mt-3">return xₙ</div>
                      </div>
                    </div>
                  )}
                </div>
              </div>

              {iterations.length > 0 && (
                <div className="bg-gray-50 rounded-lg p-6 mb-8">
                  <h2 className="text-xl font-semibold text-gray-800 mb-4">Graphical Visualization</h2>
                  {isAnimating && currentStep < iterations.length && (
                    <div className="mb-4 text-center">
                      <div className="inline-block bg-indigo-600 text-white px-6 py-3 rounded-lg">
                        <span className="text-2xl font-bold">n = {iterations[currentStep].iteration}</span>
                        <span className="ml-4 text-sm">
                          xₙ = {iterations[currentStep].x.toFixed(6)}
                        </span>
                        {method === 'fixedpoint' && (
                          <span className="ml-4 text-sm">
                            xₙ₊₁ = {iterations[currentStep].gx.toFixed(6)}
                          </span>
                        )}
                      </div>
                    </div>
                  )}
                  <div className="flex justify-center">
                    <canvas 
                      ref={canvasRef} 
                      width={600} 
                      height={400}
                      className="border border-gray-300 rounded"
                    />
                  </div>
                  <div className="mt-4 flex justify-center gap-6 text-sm">
                    {method === 'bisection' ? (
                      <>
                        <div className="flex items-center gap-2">
                          <div className="w-4 h-1 bg-purple-500"></div>
                          <span>y = f(x)</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <div className="w-4 h-1 bg-green-500"></div>
                          <span>Interval [a, b]</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <div className="w-3 h-3 rounded-full bg-red-500"></div>
                          <span>Current xₙ</span>
                        </div>
                      </>
                    ) : (
                      <>
                        <div className="flex items-center gap-2">
                          <div className="w-4 h-1 bg-purple-500"></div>
                          <span>y = g(x)</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <div className="w-4 h-1 bg-blue-500"></div>
                          <span>y = x</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <div className="w-3 h-3 rounded-full bg-red-500"></div>
                          <span>Current iteration point</span>
                        </div>
                      </>
                    )}
                  </div>
                </div>
              )}

              {iterations.length > 0 && (
                <div className="bg-gray-50 rounded-lg p-6">
                  <h2 className="text-xl font-semibold text-gray-800 mb-4">
                    Iteration Results {isAnimating && currentStep >= 0 && `(Step ${currentStep + 1}/${iterations.length})`}
                  </h2>
                  <div className="overflow-x-auto">
                    <table className="min-w-full bg-white rounded-lg overflow-hidden">
                      <thead className="bg-indigo-600 text-white">
                        <tr>
                          <th className="px-6 py-3 text-left">n</th>
                          <th className="px-6 py-3 text-left">xₙ</th>
                          {method === 'bisection' ? (
                            <>
                              <th className="px-6 py-3 text-left">f(xₙ)</th>
                              <th className="px-6 py-3 text-left">Error</th>
                            </>
                          ) : (
                            <th className="px-6 py-3 text-left">|xₙ₊₁ - xₙ|</th>
                          )}
                        </tr>
                      </thead>
                      <tbody className="divide-y divide-gray-200">
                        {iterations.map((iter, idx) => (
                          <tr 
                            key={idx} 
                            className={idx === currentStep ? 'bg-yellow-100' : 'hover:bg-gray-50'}
                          >
                            <td className="px-6 py-3">{iter.iteration}</td>
                            <td className="px-6 py-3 font-mono">{iter.x.toFixed(10)}</td>
                            {method === 'bisection' ? (
                              <>
                                <td className="px-6 py-3 font-mono">{iter.fx.toExponential(4)}</td>
                                <td className="px-6 py-3 font-mono">{iter.error.toExponential(4)}</td>
                              </>
                            ) : (
                              <td className="px-6 py-3 font-mono">{iter.error.toExponential(4)}</td>
                            )}
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                  {iterations.length > 0 && (
                    <div className={`mt-4 p-4 rounded-lg ${
                      iterations[iterations.length - 1].error < tolerance ? 'bg-green-100' : 'bg-yellow-100'
                    }`}>
                      <p className={`font-semibold ${
                        iterations[iterations.length - 1].error < tolerance ? 'text-green-800' : 'text-yellow-800'
                      }`}>
                        {iterations[iterations.length - 1].error < tolerance
                          ? `✓ Converged! ${method === 'bisection' ? 'Root' : 'Fixed point'}: x ≈ ${iterations[iterations.length - 1].x.toFixed(10)}`
                          : iterations[iterations.length - 1].iteration >= maxIter - 1
                            ? `⚠ Max iteration reached. Current estimate: x ≈ ${iterations[iterations.length - 1].x.toFixed(10)}`
                            : `Current estimate: x ≈ ${iterations[iterations.length - 1].x.toFixed(10)}`
                        }
                      </p>
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.render(<NumericalMethods />, document.getElementById('root'));
  </script>
</body>
</html>
